背景

最近公司的客户要求，分配给员工的任务除了有微信通知外，还希望PC端的网页也能实时收到通知。管理员分配任务是在我们的系统A,而员工接受任务是在系统B。两个系统都是现在已投入使用的系统。
技术选型

       根据需求我们最终选用SpringAOP+RabbitMQ+WebSocket。

       SpringAOP可以让我们不修改原有代码，直接将原有service作为切点，加入切面。RabbitMQ可以让A系统和B系统解耦。WebSocket则可以达到实时通知的要求。

SpringAOP

AOP称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待。是Spring的核心模块，底层是通过动态代理来实现（动态代理将在之后的文章重点介绍）。

基本概念

Aspect(切面)：通常是一个类，里面可以定义切入点和通知。

JointPoint(连接点)：程序执行过程中明确的点，一般是方法的调用。

Advice(通知)：AOP在特定的切入点上执行的增强处理，有before,after,afterReturning,afterThrowing,around。

Pointcut(切入点)：就是带有通知的连接点，在程序中主要体现为书写切入点表达式。

通知类型

Before：在目标方法被调用之前做增强处理。

@Before只需要指定切入点表达式即可

AfterReturning：在目标方法正常完成后做增强。

@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值

AfterThrowing：主要用来处理程序中未处理的异常。

@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名

来访问目标方法中所抛出的异常对象

After：在目标方法完成之后做增强，无论目标方法时候成功完成。

@After可以指定一个切入点表达式

Around：环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint。

 
RabbitMQ

（图摘自：https://www.cnblogs.com/dwlsxj/p/RabbitMQ.html）

从图中我们可以看到RabbitMQ主要的结构有：Routing、Binding、Exchange、Queue。

Queue

Queue（队列）RabbitMQ的作用是存储消息，队列的特性是先进先出。

Exchange

生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，还会将不符合路由规则的消息丢弃。

Routing

       用于标记或生产者寻找Exchange。

Binding

       用于Exchange和Queue做关联。

Exchange Type

fanout

fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。

direct

direct会把消息路由到那些binding key与routing key完全匹配的Queue中。

topic

direct规则是严格意义上的匹配，换言之Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue，那么topic这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。

headers

headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。

 
WebSocket

了解websocket必须先知道几个常用的web通信技术及其区别。

短轮询

　　短轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。

　　这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。

　　因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。

长轮询/comet

　　comet指的是，当服务器收到客户端发来的请求后，不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)后关闭连接。

　　长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。

SSE

　　SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。

　　SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。并且SSE的实现非常简单，不需要依赖其他插件。

WebSocket

　　WebSocket是Html5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。

　　WebSocket的优点是实现了双向通信，缺点是服务器端的逻辑非常复杂。现在针对不同的后台语言有不同的插件可以使用。

四种Web即时通信技术比较

　　从兼容性角度考虑，短轮询>长轮询>长连接SSE>WebSocket；

　　从性能方面考虑，WebSocket>长连接SSE>长轮询>短轮询。




总体流程：

1、对于系统B，每个登陆的用户都会和服务器建立websocket长连接。

2、系统A生成任务，AOP做出响应，将封装的消息发送给MQ。

3、系统B中的MQ监听发现队列有消息到达，消费消息。

4、系统B通过websocket长连接将消息发给指定的登陆用户。

